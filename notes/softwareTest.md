# 软件测试小结

## 目录
### 目录
<!-- GFM-TOC -->
* [软件测试与质量](#软件测试与质量)
  * [1 软件测试](#1-软件测试)
  * [2 软件缺陷](#2-软件缺陷)
  * [3 测试用例](#3-测试用例)
  * [4 测试分类](#4-测试分类)
  * [5 软件质量](#5-软件质量)
* [黑盒测试](#黑盒测试)
  * [1 黑盒测试概述](#1-黑盒测试概述)
  * [2 边界值测试方法](#2-边界值测试方法)
  * [3 等价类测试](#3-等价类测试)
  * [4 基于场景的测试](#4-基于场景的测试)
* [白盒测试](#白盒测试)
  * [1 白盒测试概述](#1-白盒测试概述)
  * [2 控制流分析技术](#2-控制流分析技术)
  * [3 对判定节点展开测试用例设计](#3-对判定节点展开测试用例设计)
    * [逻辑覆盖：对判定的测试](#逻辑覆盖对判定的测试)
    * [要解决的问题](#要解决的问题)
    * [1-语句覆盖](#1-语句覆盖)
    * [2-判定覆盖](#2-判定覆盖)
    * [3-条件覆盖](#3-条件覆盖)
    * [4-判定/条件覆盖](#4-判定条件覆盖)
    * [5-条件组合覆盖](#5-条件组合覆盖)
    * [6-修正的判定/条件覆盖](#6-修正的判定条件覆盖)
    * [对判定的测试小结](#对判定的测试小结)
    * [图解总结](#图解总结)
    * [注意点小结](#注意点小结)
  * [4 静态白盒测试](#4-静态白盒测试)
  * [5 路径测试](#5-路径测试)
  * [6 独立路径测试用例设计](#6-独立路径测试用例设计)
  * [7 场景爆炸](#7-场景爆炸)
* [测试管理及工具](#测试管理及工具)
  * [1 测试用例管理](#1-测试用例管理)
  * [2 缺陷管理](#2-缺陷管理)
  * [3 管理工具TC实现测试管理](#3-管理工具tc实现测试管理)
    * [TC安装教程](#tc安装教程)
    * [TC概述](#tc概述)
    * [TC的基本使用流程](#TC的基本使用流程)
    * [设计测试计划和测试需求](#设计测试计划和测试需求)
    * [设计测试场景和测试用例](#设计测试场景和测试用例)
    * [构建测试集并关联测试集](#构建测试集并关联测试集)
    * [测试执行和缺陷管理](#测试执行和缺陷管理)
* [功能测试与性能测试](#功能测试与性能测试)
  * [1 功能测试与工具](#1-功能测试与工具)
  * [2 AR](#2-ar)
  * [3 性能测试与工具](#3-性能测试与工具)
  * [4 PR](#4-pr)
* [单元测试](#单元测试)
  * [1 单元测试](#1-单元测试)
  * [2 代码扫描工具CA](#2-代码扫描工具ca)
  * [3 CA的使用](#3-ca的使用)





# 软件测试与质量

## 1 软件测试
### 为什么需要软件测试 
- 确保软件产品质量：软件测试是软件产品质量保证的重要措施之一
- 术业有专攻：软件测试人员比其他人做软件测试测试工作，效率更高，效果更好；

### 哪些人需要了解软件测试
- 用户：参与需求验证和验收测试；
- 项目经理：参与测试计划制定；
- 程序员：完成单元测试；
- 测试员：设计和执行测试。

### 软件测试定义
- 测试定义
  - 通过设计和运行测试用例，来校验被测系统的实际输出与预期输出是否一致，最终目标是保证系统应符合需求。
    - 根本目的：确保被测系统符合用户需求
    - 基本手段：设计测试用例
    - 执行方式：手工/自动化
    - 测试策略：动态运行/静态审阅
    - 通用流程：计划、设计、实施、评估
  - 软件测试以《需求》为中心。
  - 需求：
      - 定义需求(委托方)--分析需求(双方)--实现需求(研发)--校验需求(测试)。
- 测试分类：
  - 软件测试包括动态测试和静态检查两类方法；(两者均为手工测试)
  - 测试的执行包括人工和自动化两类策略。

### 软件测试流程
- 流程：计划、设计、实施、评估。
- 计划：
  - 输入：需求规格说明，项目计划；
  - 输出：测试计划。
- 设计
  - 输入：需求，设计文档，测试计划；
  - 输出：测试用例，测试过程。
- 实施
  - 输入：测试用例，测试过程，需求；
  - 输出：测试驱动模块，测试桩模块，测试脚本。
- 评估
  - 输入：测试用例，缺陷报告，测试标准；
  - 输出：测试评估报告。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 2 软件缺陷
### 定义
- 软件测试员认为软件难以理解、不易使用、运行速度缓慢，或者最终用户认为不好，则是缺陷。

### 正式定义
- 软件未达到需求规格说明书中指明的功能，则是缺陷。
  - 检查正常功能、正常流程；
  - 检查性能
- 软件出现了需求规格说明书中指明不会出现的错误，则是缺陷。
  - 检查异常情况
  - 检查无效用户输入的识别能力
  - 检查无效用户输入的处理能力
- 软件功能超出需求规格说明书中指明的范围，则是缺陷。
  - 无意加入，过错缺陷
  - 人为加入，需求缺陷
- 软件未达到需求规格说明书中虽未指出但应达到的目标，则是缺陷。
  - 隐含特性，需求缺陷
- 小结：
  - 未达需求；指明不出现；超出需求；未达隐含需求。 

### 常见问题
- 问题1：需求模糊不清。
  - 解决：对需求进行书面约定；需求规格说明。
- 问题2：需求变化无常。
  - 必须确保需求的稳定。

### 建议
- 根据用户的意见和反馈执行测试；
- 依据需求规格说明书，针对系统在有效输入及有效操作下的正常功能进行测试；
- 依据需求规格说明书的描述或个人经验，针对系统在异常情况或无效输入下的软件容错能力进行测试；
- 程序员应遵循良好的开发习惯，与用户和项目组成员及时沟通，避免植入无依据的软件缺陷；
- 需求分析阶段强调测试专家的介入，从测试的视角完善需求规格说明，提高系统的外部环境容错能力。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 3 测试用例

### 定义
- 基于风险最低、效率最高、分而治之的测试设计原则；
- 能代表需求的小的测试单元，描述用户预期输出，反映系统实际执行结果。

### 测试用例组成
- 输入+输出+测试环境
  - 输入：测试数据和操作步骤
  - 输出：系统预期执行结果
  - 测试环境：是系统环境设置，即进行软件测试所必需的工作平台和前提条件
- 具体：
  - 分为9个方面：用例编号/测试项/测试标题/用例属性/重要级别/预置条件/测试输入/操作步骤/预期结果/实际输出
　- 一般情况下分为以上几项可根据公司要求进行增删

### 测试用例的基本属性
- 典型性：
  - 能揭示最有可能存在缺陷的地方，能代表和覆盖合理与不合理、合法或不合法的情况。
- 可测试性：
  - 一个测试用例的预期输出必须是可以检验的，可以根据相关开发文档得到明确的、可判定的结论。
- 可重现性：
  - 对于相同的测试用例，系统的预期执行结果应该完全相同；
  - 否则，如果系统预期输出存在不确定性，一旦实际运行该测试用例，也无法进行校验。
- 独立性：
  - 测试用例应尽量独立

### 测试用例的设计
- 输入数据
  - 正常数据
  - 错误数据
    - 满足数据类型，不在有效取值范围内
    - 不完全满足数据类型
    - 输入条件缺失
  - 边界数据

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 4 测试分类

### 不同角度的测试分类
- 从测试阶段或对象的角度：
  - 单元测试、集成测试、系统测试和验收测试；
  - 对应软件开发的四个阶段：
    - 需求分析-->概要设计-->详细设计-->编码阶段 
- 从测试技术的角度：
  - 黑盒测试、白盒测试和灰盒测试；
- 从测试目标的角度：
  - 回归测试、功能测试、性能测试、Alpha测试、Beta测试、压力测试、负载测试、安全性测试、配置测试、安装测试、可用性测试、可恢复性测试等。
- 从测试执行方式的角度：
  - 手动测试、自动化测试和半自动化测试。 

### 从测试阶段或对象的角度
- V模型：与软件开发阶段呼应
  - 软件开发：需求分析-->概要设计-->详细设计-->编码阶段
  - 软件测试：单元测试-->集成测试-->系统测试-->验收测试
  ![v模型](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/01-V%E6%A8%A1%E5%9E%8B.png)
- 单元测试
  - 是针对每个单元的测试。
  - 用于验证一个单元模块的功能是否正常。
  - 一个单元模块可以包括几行或上百行代码。
  - 单元测试与编码过程是紧密联系的，单元测试有时也认为是编码阶段的一个活动。
- 集成测试：
  - 是将不同单元模块组合在一起，形成更大组件的过程。
  - 用于查找单元或组件间的接口错误，其关注的重点是那些在单元测试中不能被发现的缺陷。
- 系统测试：
  - 检验软件产品能否与系统的其他部分（比如，硬件、数据库及操作人员）协调工作。
  - 用于评估整个系统的行为并确保系统行为符合用户需求，并评估系统与硬件设备、运行环境和应用程序等之间的接口。
- 验收测试：
  - 部署软件之前的最后一个测试操作。
  - 测试范围类似系统测试，通常由系统提供者和客户共同完成的。
  - 验收测试使客户确信应用程序具有所需的特性并且能够正确的运行。

### 从测试技术的角度
- 黑盒测试：
  - 关注的是与产品的外部行为相关的缺陷，此时并不考虑产品的内部结构或运行逻辑。
- 白盒测试：
  - 关注的是与代码内部结构相关的缺陷，因此，需要测试人员掌握一定的编程技术。 
- 灰盒测试：
  - 是综合运用黑盒测试和白盒测试技术的一种混合测试方法。

### 从测试目标的角度
- 功能测试：
  - 针对软件功能需求进行测试，目的是检查应用程序的行为是否符合预期。
- 性能测试：
  - 用于验证系统是否满足规格说明的性能需求，例如容量和响应时间等。
- Alpha测试（α测试）：
  - 在软件发布前，有时会让小规模、有代表性的潜在用户试用软件;
  - 由开发机构人员来模拟潜在用户开展测试，称为α测试。
- Beta测试（β测试）：
  - 软件的早期版本被发布给具有代表性用户群来测试，称为β测试。
  - β测试常被用于面向大众市场的系统、计算机游戏和类似的应用程序 (游戏公测)。
- 回归测试：
  - 是软件版本修改后的重新测试，可应用于所有测试级别;
  - 目的是确保被修改组件的行为没有改变，不会造成意外结果.
- 压力测试：
  - 以设计的最大负载或超过最大负载来运行软件，用于确定系统运行的负载界限。
- 负载测试：
  - 通过测试系统在资源超负荷情况下的表现，以发现设计上的错误或验证系统的负载能力。
- 安全性测试：
  - 是对产品进行检验，以验证产品符合安全需求定义和产品质量标准的过程。
  - 用于测试系统在遭遇未授权访问、计算机犯罪和破坏时是否能保护自己
- 配置测试：
  - 当开发的系统需要应用于多种环境配置时，需要对每种配置进行测试，以检测系统行为是否符合规格要求。
  - 包含硬件配置和软件配置。
- 安装测试：
  - 在目标环境中通过安装来验证软件及其安装过程。
  - 目的是确保该软件在正常或异常情况的不同条件下都能进行安装，且安装后可立即正常运行。
- 可用性测试：
  - 用于评估系统使用的简易程度，交互是否具有人机工程学设计以及用户文档使用的有效性。
- 可恢复性测试：
  - 用于检验系统在灾难或意外宕机后的重启能力。

### 从测试执行方式的角度
- 手动测试：
  - 人工执行测试。
  - 即根据测试用例中描述的规程，不借助特殊的软件工具，人工来运行被测系统，观察系统实际输出是否符合测试用例的预期输出。
- 自动化测试：
  - 软件测试的自动化，是一个将以人为驱动的测试行为转化为机器执行的过程。
  - 目的是节省人力、时间或硬件资源，并提高测试效率。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 5 软件质量

### 软件质量定义
- 质量
  - ISO8402关于质量的定义：
    - 反映实体满足明确或隐含需要能力的特性总和。
    - 在合同环境中，需要是规定的，而在其他环境中，隐含需要应加以识别和确定
    - 在许多情况下，需要会随着时间而改变，要求定期修改规范
- 质量的要素
  - 实体
    - 实体是质量的主体，即测量的主体
    - 一般指产品，也可以是活动、过程、组织、人，或者它们的组合
  - 特性集合
    - 表示度量
    - 特性必须可以测量，定性或定量方式得到指导性结论
  - 需求 
- 软件质量
  - 反映软件满足明确或隐含需要能力的特性总和。
  - 客观而言，软件质量是软件具有某种能力的属性，这是前提条件。
  - 主观而言，软件具有的能力对应不同层次的用户需求。
    - 显式需求；隐式需求；实际需求。(难度或重要度由小到大)
- 狭义和广义的软件质量
  - 狭义的软件质量：软件的内部质量，即软件无“故障”；
  - 广义的软件质量：产品质量、过程质量和客户满意度。
- GB/T 11457-2006《软件工程术语》
  - 软件质量是软件产品中能满足给定需要的性质和特性的总体。
  - 软件具有所期望的各种属性的组合程度。
  - 顾客和用户觉得软件满足其综合期望的程度。 
  - 确定软件在使用中将满足顾客预期要求的程度。

### 软件测试和软件质量
- 软件测试是软件质量保证的关键步骤。
- 但提高软件质量的途径是改进软件开发过程的质量，而不是提高软件测试。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 黑盒测试

## 1 黑盒测试概述

### 黑盒测试的基本原理
- 原理：
  - 只知道系统输入和预期输出，不需要了解程序内部结构和内部特性的测试方法就称为黑盒测试。
- 原理图解
  ![黑盒测试的基本原理](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/02-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png)

### 黑盒测试的优缺点
- 优势
  - 方法简单有效
  - 可以整体测试系统的行为
  - 开发与测试可以并行
  - 对测试人员技术要求相对较低
- 劣势
  - 入门门槛低

### 测试方法的评价标准
- 评价标准
  - 在最短时间内，以最少的人力，有利于发现最多的，以及最严重的缺陷。
  - 精确的：测试针对性强
  - 完备的：测试覆盖全面，无漏洞
  - 无冗余：测试用例所关联的风险有所区别
  - 简单的：测试方法简单易行
  - 易于调试：缺陷定位难度
- 原则
  - 一个中心，两个坚持
  - 以用户需求为中心；
  - 坚持高效的测试用例设计；
  - 坚持缺陷的快速处理。
- 测试方法的评价
  - 测试用例的覆盖度：高
  - 测试用例的数量：少
  - 测试用例的冗余度：低
  - 测试方法的复杂度：低

### 黑盒测试用例设计方法
- 基于用户需求的测试；
- 边界值分析方法；
  - 围绕被测系统边界展开测试用例设计的问题。
- 等价类划分方法；
  - 基于等价划分的思想，使用有限的测试用例达到穷尽测试的目标
- 错误推测方法；
- 因果图方法；
- 判定表驱动分析方法；
- 正交实验法；
- 场景法。
  - 何面向业务流程进行测试设计的问题

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 2 边界值测试方法
### 要解决的问题
- 边界在哪里?
  - 边界点就是可能导致被测系统内部处理机制发生变化的点
  - 需求中有利于识别边界点的文字:
    - 位置，尺寸，数量，长度，速度，高度，距离，质量，时间…
  - 可能的边界点:
    - 第一个/最后一个，最小/最大，最少/最多，最短/最长，最快/最慢，最高/最低，最近/最远，最轻/最重，最早/最晚…
- 如何定义边界的邻域?
  - 单边界值
- 如何选择测试数据？
- 如何设计测试用例？

### 面向输入域的边界值测试
- 找到系统输入条件，基于独立性原则，确定每个输入条件的边界点。 
- 围绕每个边界点，确定边界附近的邻域范围，并挑选测试数据。
  - 若以 a 为边界值，则通常选择 a-δ, a, a+δ为测试数据，一般取δ = 1。 
- 根据选定的测试数据，基于单边界原则，设计测试用例。
- 根据系统需求，补充边界测试用例。

### 面向输出域的边界值测试
- 若被测对象的输入域与输出域很不相似，则可能需要面向输出域补充进行边界值测试，
- 一般步骤如下：
  - 找到系统输出，确定输出的边界点。
  - 围绕每个边界点，确定边界附近的邻域范围，并挑选测试数据。
    - 若以 a 为边界值，通常选择 a-δ, a, a+δ为测试数据，一般取δ = 1。 
  - 根据选定的输出域测试数据，确定输入域对应的输入条件及数据，并设计测试用例。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 3 等价类测试

### 面向输入域的等价类测试
- 基本原理
  - 采用分而治之的思想，将输入域进行等价划分；
  - 其中，等价划分满足 3 个约束，然后在每个等价类中仅抽取一个数据
  - 从而将不可能的穷尽测试转化为有限个数据构成的测试用例的集合。 
- 3个约束：
  - 分而不交：
    - 划分出的任意两个等价类之间不存在交集；
    - 测试无冗余。
  - 合而不变：
    - 所有等价类的并集仍然是原始的输入域；
    - 测试无漏洞。
  - 类内等价：
    - 任意一个等价类中，所有数据相互“等价”；
    - 以一代全。
- 等价类的划分
  - 有效等价类
    - 输入域中一组有意义的数据的集合
    - 有效等价类被用于检验系统指定功能和性能能否正确实现
  - 无效等价类
    - 输入域中一组无意义的数据的集合
    - 无效等价类被用于检验系统的容错性
  - 针对是否对无效数据进行测试，可以将等价类测试分为：
    - 标准(一般)等价类测试
    - 健壮等价类测试 
- 设计测试用例
  - 弱覆盖
    - 测试用例应覆盖所有的有效等价类
  - 强覆盖
    - 测试用例应覆盖所有的有效等价类的组合
    - 例如：当有效等价类有多个范围时，弱覆盖无法覆盖所有情况。
- 等价划分的陷阱1
  - 确定输入条件时，可能会改变原始输入域
    - 例如：以独立性原则，将日期设为1-31日时，可能超过原范围。
    - 这样得到的测试用例仍正确，没有漏洞，但有冗余。
  - 两种划分等价类的方式:
    - 基于系统实现的等价划分：
      - 从程序员实现系统的角度出发，多关注接口。
    - 基于用户需求的等价划分：
      - 从功能和业务处理机制角度出发，多关注隐含系统内部处理流程。
  - 总结：
    - 尽量从用户角度分析需求，避免改变原始输入域。
- 等价划分的陷阱2
  - 对有效域和无效域可以用相同方式进行等价类测试吗？
    - 有效等价类
      - 输入域中一组有意义的数据的集合
      - 有效等价类被用于检验系统指定功能和性能能否正确实现
    - 无效等价类
      - 输入域中一组无意义的数据的集合
      - 无效等价类被用于检验系统的容错性
      - 可能出现无法定位缺陷的问题
  - 总结：
    - 在有效域：使用组合机制
    - 在无效域：使用单缺陷机制。
- 等价划分的陷阱3
  - 如何选择合适的覆盖指标 
    - 划分出最多有效等价类的那个输入条件决定弱覆盖指标的最少测试用例数。
    - 强覆盖指标下，测试用例的数量是每个输入条件所拥有的有效等价类数量的乘积。
  - 测试用例规模：
    - 弱 <<< 强，可在项目紧急情况下适当选择弱覆盖。
  - 总结：
    - 一般采用强覆盖；
    - 进度紧张时可选弱覆盖。
- 等价划分的陷阱4
  - 等价类测试真的没有漏洞，没有冗余吗？
    - 等价划分不彻底：将导致测试的漏洞。
      - 例如：日期设计中，31日后一天的处理，其他月份是本年下个月，而12月的31日会跨年，应分开设置。
    - 输入条件直接存在关联时：引入独立性原则将造成测试冗余。
  - 总结：
    - 务必确保数据的等价性，避免漏洞；
    - 等价划分兼顾输入的关联性，避免冗余。
- 面向输入的等价类测试的基本步骤如下：
  - 在有效域内：
    - 基于独立性原则，将数据划分到不同的有效等价类中，然后选择弱覆盖标准，或强覆盖标准设计测试用例。
    - 确保每个测试用例覆盖的均为有效等价类。
  - 在无效域内：
    - 将数据划分到不同的无效等价类中，然后基于单缺陷原则设计测试用例。
    - 不应该出现多个无效等价类组合成测试用例的情况。
  - 注意：
    - 受到输入条件之间的关联性影响，以及等价划分的正确性影响，等价类测试得到的测试用例不一定能保证无漏洞、无冗余。


### 面向输出域的等价类测试
- 若被测对象的输入域与输出域很不相似，则可能需要面向输出域补充进行等价类测试。
- 一般步骤如下：
  - 在输出域内，划分等价类；
  - 在每个等价类中随意抽取一个数据；
  - 针对选择的输出测试数据，确定输入条件及数据，设计测试用例。

### 注意：  
- 输入域：需要严格区分有效域和无效域。
- 输出域：不存在无效输出域的概念。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 4 基于场景的测试

### 辨析
- 边界值测试和等价类测试：
  - 主要解决数据穷尽测试的问题；
  - 面向数据的测试，忽略了对流程的考虑。 
- 面对业务流程的测试：
  - 可基于事件流的思想采用场景法进行测试设计。

### 产生原因
- 越来越多的软件系统采用事件触发来控制流程
- 事件触发时的情景形成场景
- 同一事件不同的触发顺序和处理结果形成事件流

### 基于场景的测试基本原理
- 以事件流为核心
  - 包括：基本流和备选流
- 场景：
  - 从系统某个初始态开始，到达某个结束状态为止所经过的路径就构成一个用例场景。
- 图解
  ![基于场景测试的基本原理](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/02-%E5%9F%BA%E4%BA%8E%E5%9C%BA%E6%99%AF%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png)

### 场景法面临的问题
- 如何定义基本流和备选流? 
  - 基本流：中轴线，是从初始态到终止态的一个最主要的业务流程。
    - 测试中，至少需要确保系统基本流的执行是完全正确的。
    - 对系统从某个初始态到某个终止态的事件流而言，基本流是唯一的。
  - 基本流选择：
    - 应选择容易出错的，或者出错后导致损失严重的高风险事件流作为基本流。
  - 高风险事件流：
    - 操作频率高
    - 涉及业务规则复杂
    - 涉及重要功能
    - 涉及用户类型广泛
    - 涉及用户数量大
    - 涉及交互复杂
  - 备选流：仅为整个执行过程中的一个片段。
    - 备选流可以有多个；
      - 基本流的判定节点越多，产生的备选流越多。
    - 节点选择多样：
      - 起始节点从基本流的某个判定节点开始；
      - 起始节点从其他备选流的某个判定节点开始；
      - 终止节点是基本流上的某个状态；
      - 终止节点是其他的系统终止状态；
      - 备选流上的每个节点执行后可以继续往下执行(判定结构)，也可以返回基本流上的某个节点继续执行(循环结构)。
  - 基本流与备选流的区别
    ![基本流与备选流的区别](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/02-%E5%9F%BA%E6%9C%AC%E6%B5%81%E4%B8%8E%E5%A4%87%E9%80%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB.png)
- 如何定义场景？
  - 场景定义：
    - 可以看做是基本流和备选流的有序集合。
    - 一个场景中至少应包含一条基本流。
  - 场景选择：场景流+若干备选流。
    - 场景1：基本流
    - 场景2：基本流+备选流1
    - 场景3：基本流+备选流1+备选流2
    - 场景4：基本流+备选流3
    - 场景5：基本流+备选流4
    - 场景6：基本流+备选流3+备选流1
    - 场景7：基本流+备选流3+备选流1+备选流2
    - 场景8：基本流+备选流3+备选流4
- 如何设计测试用例？
  - 找到输入条件
  - 判断是否有效条件
  - 判断是否触发条件
  - 需要取哪些测试数据
  - 得到系统预期输出

### 基于场景的测试用例设计一般步骤
- 步骤：
  - 基于风险确定基本事件流和备选事件流。
  - 以基本事件流和备选事件流构建场景。
  - 从场景设计测试用例
    - 即找到输入条件，判断是否有效条件、是否触发条件、需要取哪些测试数据，并得到系统预期输出。
- 注意：
  - 从原理图可以看出，如果备选事件流过多，则将导致要测试的场景数量会变得十分庞大；
  - 因此，备选事件流的选择需要结合等价划分的结果，在某个节点选择备选事件流时，凡是不符合正常业务流程的，均可统一划归为异常业务流程，作为一个备选事件流。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 白盒测试

## 1 白盒测试概述

### 白盒测试的基本原理
- 原理
  - 白盒测试就是基于程序的源代码，已知产品的内部工作过程，主要对程序内部结构展开测试，关注程序实现细节的测试方法。
- 原理图解
  ![白盒测试的基本原理](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png)

### 关注的对象
- 源代码
  - 阅读源代码，检验代码的规范性，
  - 对照函数功能查找代码的逻辑缺陷、内存管理缺陷、数据定义和使用缺陷等
- 程序结构
  - 使用与程序设计相关的图表，找到程序设计的缺陷，或评价程序的执行效率

### 白盒测试的优缺点
- 优势
  - 针对性强，便于快速定位缺陷
  - 在函数级别开始测试工作，缺陷修复的成本低
  - 有助于了解测试的覆盖程度
  - 有助于代码优化和缺陷预防
- 不足
  - 对测试人员要求高
    - 测试人员需要具备一定的编程经验
    - 白盒测试工程师需要具备广博的知识面
  - 成本高
    - 白盒测试准备时间较长

### 白盒测试的经济学问题
- 软件测试是不完备的
- 软件测试是有风险的
- 测试设计应达到的目标
  - 提高效率
  - 降低风险

### 白盒测试用例设计方法
- 语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 2 控制流分析技术

### 控制流分析要解决的问题
- 什么因素导致程序结构变得复杂？-- 判定节点
- 如何衡量程序结构的复杂程度？ -- 判定节点
- 控制程序执行流程发生变化的主要因素是什么？
- 如何测试这些因素，并确保测试的效率？

### 控制流分析的内容
- 关注判定节点固有的复杂性
  - 焦点：判定表达式
  - 方法：逻辑覆盖测试
- 关注判定结构与循环结构对执行路径产生的影响
  - 焦点：路径
  - 方法：独立路径测试 
- 关注循环结构本身的复杂性
  - 焦点：循环体
  - 方法：基于数据的静态分析

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 3 对判定节点展开测试用例设计

### 逻辑覆盖：对判定的测试
- 关注点：
  - 判定表达式本身的复杂度
- 原理：
  - 通过对程序逻辑结构的遍历，来实现测试对程序的覆盖
- 原则：
  - 对程序代码中所有的逻辑值，都需要测试真值（True）和假值（False）的情况

### 要解决的问题
- 对于选定的覆盖指标，如何控制测试用例规模，提高测试用例典型性，避免测试漏洞？
- 如何选择合适的覆盖指标？

### 1-语句覆盖
- 含义
  - 语句覆盖(Statement coverage)
  - 设计测试用例时应保证程序中每一条可执行语句至少应执行一次
- 图示
  ![语句覆盖示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E8%AF%AD%E5%8F%A5%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)
- 特点
  - 控制流图中的点覆盖
- 不足
  - 语句覆盖是最弱的覆盖准则
  - 关注语句，而非关注判定节点
  - 对隐式分支无效
- 对策
  - 优选测试数据
  - 更强的覆盖准则：判定覆盖

### 2-判定覆盖
- 含义
  - 判定覆盖(Branch coverage)
  - 设计测试用例时应保证程序中每个判定节点取得每种可能的结果至少一次。
- 图示
  ![判定覆盖示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E5%88%A4%E5%AE%9A%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)
- 特点
  - 控制流图中的边覆盖
- 不足
  - 仅关心表达式的整体取值，不能覆盖到每个子条件的所有取值情况。
    - 例如：当判定节点包含的是复合判定表达式时，即由多个简单判定条件连接而成时。
- 对策
  - 更严格的覆盖检查

### 3-条件覆盖
- 含义
  - 条件覆盖(Condition coverage)
  - 设计测试用例时应保证程序中每个复合判定表达式中，每个简单判定条件的取真和取假情况至少执行一次
- 图示
  ![条件覆盖示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)
- 不足
  - 不一定满足判定覆盖。
  - 即判定节点局部全覆盖不等于判定节点整体全覆盖。

### 4-判定/条件覆盖
- 含义
  - 判定/条件覆盖(Branch/Condition coverage)
  - 设计测试用例时应满足判定节点的取真、取假分支至少执行一次；
  - 且每个简单判定条件的取真和取假情况也至少执行一次
- 图示
  ![判定/条件覆盖示例](https://github.com/anliux/SoftwareTest/blob/master/intro/images/03-%E5%88%A4%E5%AE%9A%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)
- 特点
  - 判定覆盖+条件覆盖
- 不足
  - 测试用例设计复杂

### 5-条件组合覆盖
- 含义
  - 条件/组合覆盖(Condition combination coverage)
  - 设计测试用例时应满足每个判定节点中，所有简单判定条件的所有可能的取值组合情况至少执行一次
  - 以测试条件的冗余，换取方法的简单性。
  - 本质：真值表
- 图示
  ![条件组合覆盖示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E6%9D%A1%E4%BB%B6%E7%BB%84%E5%90%88%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)
- 特点
  - 方法简单
- 不足
  - 测试用例太多，冗余严重

### 6-修正的判定/条件覆盖
- 含义 
  - 修正的判定/条件覆盖(Modified Condition/Decision coverage)
  - 在满足判定/条件覆盖的基础上，每个简单判定条件都应__独立地影响__到整个判定表达式的取值。
- 真值表图示
  ![修正的判定/条件覆盖示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E4%BF%AE%E6%AD%A3%E7%9A%84%E5%88%A4%E5%AE%9A%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)
- 特点
  - 判定覆盖+条件覆盖+独立影响性
  - 实质：利用简单判定条件的独立影响性来消除测试用例的冗余。
  - 注：用例数下界为条件数+1，上界为条件数的两倍
- 测试用例设计的一般步骤
  - 列出所有简单判定条件；
  - 构建真值表；
  - 对每个简单判定条件，找到能对整个判定结果产生独立影响的测试用例集合（简称独立影响对）
    - 即在真值表中依次固定其他简单判定条件，找到该条件的独立影响对；
  - 抽取能体现所有简单判定条件独立影响性的最少独立影响对。
- 优势
  - 综合具备条件组合覆盖的优点，有效控制了测试用例数量，消除了测试冗余。 
- 不足
  - 测试用例设计较为困难。
  - 无法处理耦合的表达式。

### 对判定的测试小结
- 考察源代码中的判定表达式进行测试
- 常见的覆盖指标
  - 语句覆盖(语句覆盖弱)
  - 判定覆盖(覆盖不全面)
  - 条件覆盖(覆盖不全面)
  - 判定/条件覆盖(设计难度大)
  - 条件组合覆盖(测试用例数量太多)
  - 修正的判定/条件覆盖
  - 注：前三个使用最广泛。判定覆盖最多。

### 图解总结
![不同覆盖指标的比较](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E4%B8%8D%E5%90%8C%E8%A6%86%E7%9B%96%E6%8C%87%E6%A0%87%E7%9A%84%E6%AF%94%E8%BE%83.png)

### 注意点小结
- 请注意：
  - 上述指标在实际使用中并不需要全部采用，通常使用较多的是判定覆盖指标。
- 其他
  - 白盒测试用例的设计并不等同于调试程序的过程中，通过简单输入一些预先设想的数据，看看程序能够返回正确结果。
  - 从代码的层面来说，测试用例设计的更多目的是为了支持自动化单元测试。
  - 以及我们通常所谈的白盒测试方法也同样适用于在功能测试中使用，这一点，在后续的路径测试中会进一步体会到。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 4 静态白盒测试

### 静态白盒测试介绍
- 定义
  - 不需要实际运行被测软件，而是直接对软件形式和结构进行分析。 
- 分类
  - 静态白盒测试主要包括代码检查、静态结构分析、代码质量度量等。

### 代码检查
- 概述
  - 主要是通过同行评审来发现缺陷；
  - 主要以评审会议为形式，通过多人对软件交付物进行检查，从而发现缺陷或获得改进优化的机会。
  - 同行评审方法遵循的评审流程大同小异，但随着这些方法的正式程度不同，适用的对象、评审形式等方面也存在一定的差异。
  - 同行评审往往需要大量投入时间和人力资源。
- 对比
  - 动态测试的局限性
    - 开发早期无法提供可运行对象，导致无法执行测试
    - 特定类型的缺陷，通过测试无法发现
  - 同行评审的优势
    - 促使参与者在有监督压力下工作，提高责任心
    - 有助于在开发早期发现需求和设计中的缺陷
    - 有助于帮助程序员发现不足，提高工作质量
- 同行评审
  - 同行评审的核心：缺陷预防
  - 目的：发现缺陷，改进开发过程
- 同行评审的方法分类
  - 审查(Inspection)
  - 团队评审(Team Review)
  - 走查(Walk Through)
  - 结对编程(Pair Programming)
  - 同行桌查(Peer Desk Check)
  - 轮查(Pass Around)
  - 特别检查(Ad hoc Review)
  - 结对编程、同行桌查、轮查、特别检查：
    - 较随意，目的是发现缺陷，过程简洁，1-2人，快速审查。
  - 审查、团队评审、走查：
    - 更正规，目的是发现缺陷，改进开发质量，被评审的对象更关键，流程更复杂。
- 同行评审的流程
  ![同行评审的流程](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E5%90%8C%E8%A1%8C%E8%AF%84%E5%AE%A1%E7%9A%84%E6%B5%81%E7%A8%8B.png)
- 评审结果
  - 正常：
    - 评审专家做好了评审准备，评审会议顺利进行，达到了预期目的，达成明确的评审结论，不需要再次评审。
  - 延期：
    - 30%以上的评审专家并未做好评审准备，会议无法正常进行，需要重新安排评审日程。
  - 取消：
    - 初审阶段就发现工作产品中存在太多问题，需要作者进行修复，然后再进行第二次同行评审。
- 评审主要参与人
  - 主持人：组织评审会议
  - 讲解员：讲解被评审的工作产品
  - 作者：被评审工作产品的提供者
  - 评审员：评审工作产品
  - 记录员：记录缺陷和决议
- 评审流程分析
  - 同行评审的有效性取决于评审流程的规范性、评审专家对工作产品和评审流程的熟悉程度，以及所有参与人员的态度等多方面因素。
  - 在缺乏规范、缺乏有效组织、缺乏责任心和检查工具的情况下，同行评审只是在浪费时间。
  - 所以，不妨从结对编程开始，从遵循行业已有的规范开始，尝试有监督的开发。

### 静态结构分析
- 概述
  - 静态结构分析就是通过分析程序相关的图表，从而快速了解程序设计和结构，更好地理解源代码，找到程序设计的缺陷和代码优化的方向。
- 具体
  - 通过引入多种形式的图表（如函数调用关系图、模块控制流图等）
  - 帮助我们快速了解程序设计和结构，更好地理解源代码，有利于找到程序设计的缺陷和代码优化的方向。
- 看函数调用关系图 
  - 从函数调用图看程序结构包括如下方面。 
  - （1）看函数调用层次。
    - 层次太深，将增大集成测试的负担，造成风险。
    - 对栈造成压力，容易导致溢出。
    - 控制单个函数的复杂度。
    - 要在函数调用层次与单个函数复杂度之间达到平衡。
  - （2）看函数调用关系，标识高风险节点。
    - 高风险节点：调用层次深；缺陷隐藏深。
    - 调用层次深的节点，根节点，出度大的节点，入度大的节点，都是高风险节点。
      - 入度越大，缺陷传播速度越快
      - 出度越大，对缺陷的敏感度越高
  - （3）看递归调用。
    - 递归调用往往对内存消耗较大。
    - 如果存在递归调用，尽量改为循环。
  - （4）看孤立节点。
    - 孤立的函数意味着不执行的场景或路径，代表编码或设计的不合理；
    - 尽量避免孤立节点
- 看控制流图 
  - 控制流图
    - 由节点和边组成的有向图
    - 节点表示一条或多条语句
    - 边表示节点之间的控制走向，即语句的执行
  - 控制流图的作用
    - 直观反映函数的内部逻辑结构
    - 展示程序中明显的缺陷
    - 揭示程序是否隐含缺陷
  - 从控制流图看程序结构包括如下方面：
  - （1）看孤立节点。
    - 从控制流图看是否存在孤立节点。
  - （2）看出口节点。
    - 理想的是单入口单出口的。
    - 多出口带来高复杂度，应尽量避免多出口。
  - （3）看环复杂度。
    - 环复杂度应控制在 10 以内。 
    - 导致环复杂度过高的主要原因：
      - 出口节点数量太多；
      - 判定节点数目太多；
      - 未采用结构化的程序设计等。
  - （4）非结构化设计。
    - 非结构化的语句：强行跳入跳出，goto，break，continue等语句导致。
    - 弊端：
      - 由于存在强制跳入跳出，导致并非所有分支都执行到结束节点，而会出现执行到其他节点退出的情况。
      - 程序可读性差，增加测试难度和工作量，容易导致缺陷，测试中不易发现。
    - 应尽量避免非结构化设计。
- 如何改进结构设计不合理的函数？
  - （1）孤立节点：避免孤立节点；
  - （2）多出口：尽量避免多次使用 return 语句，尽量将有效性校验前置；
  - （3）环复杂度：应将完成单一功能的语句块改为函数调用的方式，降低单个函数复杂度；
  - （4）非结构化设计：尽量不使用强制跳转或强制结束语句，避免非结构化设计。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 5 路径测试

### 相关概念
- 路径测试
  - 对程序路径的执行进行测试，保证路径执行是按照设计的预期进行的。
- 基于等价路径的测试图示
  ![基本等价路径的测试图示](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/04-%E5%9F%BA%E4%BA%8E%E7%AD%89%E4%BB%B7%E8%B7%AF%E5%BE%84%E7%9A%84%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%A4%BA.png)
- 基于等价路径测试的关键
  - 如何找到路径划分的规律
  - 如何定义路径的有效
  - 等价类和无效等价类
- 路径测试的法宝
  - 用于记录程序路径的地图
  - 最少线性无关路径数
  - 所有可能迅速找到缺陷的最佳独立路径

### 独立路径测试
- 独立路径测试原理图
  ![独立路径测试原理图](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/04-%E7%8B%AC%E7%AB%8B%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95%E5%8E%9F%E7%90%86%E5%9B%BE.png)
- 基于独立路径的测试
  - 若将向量空间视作向量组，则基就是向量组的极大线性无关组，维数就是向量组的秩。
  - 该向量空间内的任意向量，都可以用这组向量基来线性表示。
- 基于独立路径方法的关键
  - 如何确定向量空间的维数
  - 如何确定这组独立路径
- 等价路径与独立路径对比
  ![等价路径与独立路径对比](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/04-%E7%AD%89%E4%BB%B7%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%8B%AC%E7%AB%8B%E8%B7%AF%E5%BE%84%E5%AF%B9%E6%AF%94.png)
- 独立路径测试要解决如下三个核心问题：
  - 找到一张用于记录程序路径的地图；
  - 确定测试所需最少线性无关路径数；
  - 找到所有可能迅速找到缺陷的最佳独立路径.

### 程序图
- 定义
  - 程序图是反映程序结构复杂程序的一种图示，可以看做是一种简化、压缩的流程图或控制流图。   
- 来源
  - 从源代码得到
  - 用来表示程序结构的一种有向图
    - 由圆圈和有向线段构成
    - 圆圈（节点）：执行语句
    - 有向线段：程序执行方向
- 程序图：简化的流程图
  - 简化节点形状
- 程序图的特点
  - （1）对节点形状进行简化，采用统一的形状表示；
  - （2）忽略数据声明。
  - （3）忽略注释语句。
  - （4）压缩串行语句
  - （5）压缩循环结构。

### 环复杂度
- 定义
  - 环复杂度是一种定量描述程序结构复杂度的度量模型。
  - 能够反映判定节点和循环的引入对程序结构及执行路径数目带来的不利影响 
- 环复杂度的确定
  - （1）直观观察法。
    - 观察程序图将二维平面分割为封闭区域和开放区域的个数。 
    ![直观观察法](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/04-%E7%8E%AF%E5%A4%8D%E6%9D%82%E5%BA%A6-%E7%9B%B4%E6%8E%A5%E8%A7%82%E5%AF%9F%E6%B3%95.png)
  - （2）公式计算法。
    - 利用程序图包含的边和顶点的数量来计算环复杂度。
    - 前提条件：程序图中无孤立节点；程序图是强连通图(双向连通)。
    - V(G) = e – n + 1。 
      - e：边的数量；n：节点数
    - 对程序图改造
      - 强连通的实质：节点间双向连通
      - 正常运行的程序：从入口单向执行到出口，并退出；
      - 解决方案：构建死循环。
    ![公式计算法](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/04-%E7%8E%AF%E5%A4%8D%E6%9D%82%E5%BA%A6-%E5%85%AC%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%B3%95.png)
  - （3）判定节点法。
    - 判定节点每增加一个，环复杂度就+1
    - 前提条件：仅计算两分支的判定节点
    - V(G) = P + 1。 
    ![判定节点法](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/04-%E7%8E%AF%E5%A4%8D%E6%9D%82%E5%BA%A6-%E5%88%A4%E5%AE%9A%E8%8A%82%E7%82%B9%E6%B3%95.png)
  - 特殊情况的处理
    - 非单入单出程序；
    - 非标准判定节点。
  - 请注意这些方法使用的前提条件。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 6 独立路径测试用例设计

### 基于独立路径设计测试用例的步骤
- step1：将源代码转为程序图，作为路径测试的地图；
  - 流程图、控制流图、程序图都可以，程序图最简洁。
- step2：计算程序图的环复杂度，确定独立路径测试集合的规模；
  - 独立路径集合的规模=程序图的环复杂度。
- step3：找到所有独立路径；
  - 确定主路径；
  - 根据主路径抽取其他独立路径。
- 剔除不可行路径；
- 补充路径测试；
- 根据要覆盖的路径，设计测试用例。

### 独立路径的确定 
-  独立路径的确定包括两个步骤：
  - 确定主路径
  - 以主路径为基础确定其他路径。
- （1）确定主路径
  - 主路径就是程序图中风险最高的那条执行路径。
  - 从结构来看，就是包含判定节点数目最多的一条路径。
    - 注：判定节点直观看就是分支节点，顺序无分支节点不属于判定节点。
    ![确定主路径](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/04-%E7%A1%AE%E5%AE%9A%E4%B8%BB%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%A4%BA.png)
- （2）确定其他路径
  - 以主路径为基础，针对主路径中的每个判定节点，依次覆盖已有独立路径中尚未覆盖的判定分支，生成新的独立路径。
  - 如果主路径未覆盖程序图中所有的判定节点，则需要针对主路径未覆盖到的那些判定节点，确定其余路径，直至找到所有独立路径。
    ![确定其他路径](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/04-%E7%A1%AE%E5%AE%9A%E5%85%B6%E4%BB%96%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%A4%BA.png)

### 不可行路径问题 
- 定义
  - 不可行路径就是在程序执行中不可能执行到的路径。 
- 影响
  - 不可行路径破坏了独立路径测试的完备性和无冗余性；
  - 给测试带来额外的困难。
- 处理
  - 结合源代码抽取路径，而非仅从程序图抽取独立路径；
  - 补充其他具有较高风险的路径进行测试。
- 产生原因
  - 程序中存在相互关联的判定或循环结构
- 避免
  - 从测试的角度看待和分析需求
  - 设计合理的程序结构

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 7 场景爆炸
### 含义
- 黑盒测试中，当场景中包含的事件流越多，可构成的场景越多，可能无法穷尽，造成场景爆炸问题。

### 场景爆炸问题的解决方案 
- （1）基于独立路径构建典型场景
  - 将场景原理图看做程序图，借鉴独立路径测试方法，确定典型场景。
  - 优势：可以保证场景相互独立，无漏洞；
  - 劣势：不可避免不可行场景。
- （2）基于事件流的个数构建典型场景
  - 根据事件流的个数，本着面向缺陷隔离的独立测试原则，对每个事件流单独设计测试。
  - 优势：易于缺陷定位；
  - 劣势：不可避免不可行场景，且不保证场景独立和完备。 
- （3）基于需求构建典型场景
  - 根据原始需求设计场景。
  - 优势：保证每个场景可行；
  - 劣势：场景之间多存在冗余，且场景设计严重依赖于测试人员对需求的熟悉程度。
- 建议的使用策略
  - 当事件流之间相互独立时，建议基于独立路径设计场景。
  - 否则，建议先基于独立路径设计场景，并保证场景可行，然后基于需求补充场景。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->




# 测试管理及工具


## 1 测试用例管理

### 测试用例管理的重要性
- 测试用例数量庞大，必须有效组织起来，实现分级管理
- 测试用例是连接需求与缺陷的关键纽带
- 项目组人员众多，必须保证所有人正确理解测试用例

### 测试用例管理的两个主要问题
- 如何组织测试用例
  - 即通过分析用户需求，设计测试用例，从测试用例库中抽取不同的测试用例，构建多个测试集，
  - 在不同的测试轮次中使用不同的测试集执行测试，记录发现的缺陷，并对应到相关的测试用例。
    - ![测试用例组织图示](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/05-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%BB%84%E7%BB%87%E5%9B%BE%E7%A4%BA.png)
- 如何报告测试用例
  - 测试用例报告
    - 即通过测试用例报告来详细记录测试用例的输入、预期输出，体现测试用例与需求的对应，支持测试用例的精确执行和责任划分。
  - 报告测试用例的基本要求
    - 详细记录测试用例核心内容
    - 体现测试用例与需求的对应关系
    - 支持测试用例的精确执行
    - 支持测试用例的责任划分  
  - 测试用例报告就是要回答：
    - 谁
    - 在什么条件下
    - 对什么进行测试
    - 如何进行测试
    - 依据的需求是什么
    - 与其他测试用例有何关联
  - 测试用例报告构成
    - ![测试用例报告构成](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/05-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%8A%A5%E5%91%8A%E6%9E%84%E6%88%90.png)

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 2 缺陷管理

### 缺陷的基本属性 
- 缺陷管理概述
  - 缺陷管理：
    - 是在软件生命周期中识别和管理缺陷的过程（从缺陷的识别到缺陷的解决关闭），确保缺陷被跟踪管理而不丢失。  
  - 一般，需要跟踪管理工具来帮助进行缺陷的全流程管理。
    - 例如 jira
- 缺陷的属性
  - 缺陷的属性主要包括：可重现性，严重性，优先级，可修复性。
    - 需在报告中明确体现：可重现性，严重性，优先级
    - 不在报告中体现：可修复性
- 可重现性
  - 缺陷应可以满足不止一次地触发出现
  - 无法重现的缺陷无法修复，但不是任何缺陷都可以重现。
  - 保证发现的缺陷可以重现的措施如下：
    - 测试前：备份相关环境和数据；
    - 测试过程中：详细记录每一个执行步骤和系统的响应；
    - 一旦发现错误：尝试改变输入条件，输入数据，操作步骤，或测试环境，尝试重现缺陷；
    - 一旦确定缺陷可以重现一次：重复执行至少 3 次。
- 严重性
  - 缺陷的客观属性，用于客观评价缺陷对系统造成的破坏力。
  - 一般分为三级：严重的，一般的，次要的。
    - 严重：影响系统或数据；
    - 一般：不影响系统，影响某些功能；
    - 次要：不影响主要功能，且可以轻易处理。
- 优先级
  - 缺陷的主观属性，是指项目组对缺陷的处理优先级，带有主观意见。
  - 一般分为三级：高、中和低三种。
    - 高：必须立即修复；
    - 中 (一般)：缺陷需正常排队等待修复，但在产品发布之前必须修复；
    - 低：在时间允许的时候进行修复。
- 可修复性
  - 指缺陷在软件产品发布之前是否可以得到修复。
    - 不是所有缺陷在产品发布之前都可以得到修复；
    - 但应尽量促使缺陷在产品发布之前进行修复
  - 不修复：
    - 缺陷不被认可
    - 缺陷无需修复
    - 缺陷没时间修复
    - 修复风险太高

### 缺陷报告 
- 一份缺陷报告实际就是要回答如下问题：
  - (1) 谁，何时，在何处，发现了什么缺陷？
  - (2) 谁，何时，提出怎样的处理意见？
  - (3) 谁，何时，如何修复该缺陷？
  - (4) 谁，何时，如何验证该缺陷？测试结果如何？
- 1-测试人员负责的内容（新建）
  - 第1部分：基本信息。描述：被测对象、责任人、测试用例。
    - ![缺陷报告1-基本信息](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/05-%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A1-%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF.png)
  - 第2部分：核心信息。描述：怎样的条件下，如何操作，出现什么缺陷，基本属性如何
    - ![缺陷报告1-核心信息](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/05-%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A1-%E6%A0%B8%E5%BF%83%E4%BF%A1%E6%81%AF.png)
  - 常见的缺陷类型：
    - 功能性缺陷、性能缺陷、设计缺陷、接口缺陷、逻辑缺陷、计算缺陷、数据缺陷、用户界面缺陷、文档缺陷、配置缺陷、环境缺陷、兼容性缺陷等等
- 2-测试经理/项目经理负责的内容
  - 指定缺陷处理优先级和分配缺陷处理责任人
    - ![缺陷报告2](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/05-%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A2.png)
- 3-程序员负责的内容
  - 解决方案与修复详情
    - ![缺陷报告3](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/05-%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A3.png)
  - 常见的缺陷处理方式
    - 承认是缺陷：
      - 已修复(Fixed)：仅本项为修复缺陷。
      - 暂缓(Postponed或Later)
      - 外部原因(External或On hold)：浏览器、操作系统等影响
      - 不修复(Don’t fix)
    - 不承认是缺陷：
      - 重复的(Duplicate)
      - 不可重现(Not repro)
      - 符合设计(By design或Not a bug)
-  4-测试员负责的内容（复审）
  - 描述：缺陷是否正确的修复
    - ![缺陷报告4](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/05-%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A4.png)
- 保证缺陷得到及时提交和解决
  - 及时报告
  - 一个缺陷对应一个缺陷报告
  - 对缺陷的描述应紧凑、确切和充分，避免错误
  - 在缺陷周边进行更多测试

### 缺陷的跟踪与管理
- 缺陷跟踪概述
  - 缺陷跟踪的流程就是：缺陷从激活，到分配，到解决，最后关闭的过程。
- 图示
  - ![缺陷跟踪流程图示](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/05-%E7%BC%BA%E9%99%B7%E8%B7%9F%E8%B8%AA%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%A4%BA.png)
- 缺陷管理
  - 使用工具：jira

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 3 管理工具TC实现测试管理

### TC安装教程
- [测试管理工具TC安装手册](https://github.com/anliux/SoftwareTest/blob/master/intro/docs/5-%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%8F%8A%E5%B7%A5%E5%85%B7/5.2.0%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7TC%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C.pdf)


### TC概述
- 概述
  - TestCenter是一款功能强大测试管理工具。
  - TestCenter可以帮助您：
    - 实现测试用例的过程管理
      - 对测试需求过程、测试用例设计过程、业务组件设计实现过程等整个测试过程进行管理。
    - 实现测试用例的标准化
      - 即每个测试人员都能够理解并使用标准化后的测试用例，降低了测试用例对个人的依赖；
    - 提供测试用例复用
      - 用例和脚本能够被复用，以保护测试人员的资产；
    - 提供可伸缩的测试执行框架，提供自动测试支持；
    - 提供测试数据管理
      - 帮助用户统一管理测试数据，降低测试数据和测试脚本之间的耦合度。
- 管理内容
  - 测试需求管理
    - 支持测试需求树，树的每个节点是一个具体的需求，也可以定义子节点作为子需求。每个需求节点都可以对应到一个或者多个测试用例。
  - 测试用例管理
    - 测试用例允许建立测试主题，通过测试主题来过滤测试用例的范围，实现有效的测试。
  - 测试业务组件管理
    - 支持软件测试用例与业务组件之间的关系管理，通过测试业务组件和数据“搭建”测试用例，实现了测试用例的高度可配置和可维护性。
  - 测试计划管理
    - 支持测试计划管理、测试计划多次执行（执行历史查看）；测试需求范围定义、测试集定义。
  - 测试执行
    - 支持测试自动执行（通过调用测试工具）；
    - 支持在测试出错的情况下执行错误处理脚本，保证出错后的测试用例脚本能够继续被执行。
  - 测试结果日志察看
    - 具有截取屏幕的日志查看功能。
  - 测试结果分析
    - 支持多种统计图标，比如需求覆盖率图、测试用例完成的比例分析图、业务组件覆盖比例图等。
  - 缺陷管理
    - 支持从测试错误到曲线的自动添加与手工添加；支持自定义错误状态、自定义工作流的缺陷管理过程。
    - 相关的软件测试工具有AutoRunner和TAR

### TC的基本使用流程
- TC的基本使用流程:
  - ![TC的基本使用流程](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/05-TC%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png)
- TC的测试流程图:
  - ![TC的测试流程图](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/05-TC%E7%9A%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

### 设计测试计划和测试需求 
- 测试计划：
  - 可按版本进行管理，不同软件版本对应不同测试计划；
  - 在测试计划下，设计测试轮次，一个测试计划可以包含多个测试轮次，测试执行是按照轮次来完成的。
- 测试需求：
  - 实际对应功能需求，可通过导入 word 文档的方式批量添加需求，或者手写输入需求，最终形成需求树；
  - 测试用例必须与需求相对应。

### 设计测试场景和测试用例 
- 测试场景：
  - 针对业务流程设计的，且与测试需求相对应，包含步骤设计和数据设计。
- 测试用例
  - 与测试场景相对应，一个场景可能包含多个测试用例。
  - 测试用例的设计包括数据设计（输入数据）、步骤设计（可从场景设计中导入），和预期输出。
- 测试用例的设计方法包括：
  - 在测试场景中添加测试用例（上节中已介绍）
  - 在测试构建中，在测试用例组中添加测试用例
  - 通过设置用例模板，批量导入测试用例

### 构建测试集并关联测试集
- 首先：测试集的构建：
  - 主要用于对测试用例进行管理；
  - 在版本更新迭代中，通过测试集将测试用例组合起来
  - 不同的版本可选择不同的测试集进行执行
- 具体方式包括：
  - 测试集树中添加测试集组
  - 添加测试集
  - 在测试集中添加测试用例
- 然后：在测试计划中关联测试集：
  - 从而将需求（对应到）测试用例，测试轮次（关联）测试集 测试用例，相互对应起来。
- 最后：发起手工执行

### 测试执行和缺陷管理
- 测试执行：
  - 发起手工执行之前，由项目经理分配执行人；
  - 执行人对照用例信息，进行手工执行：
    - 如果执行失败，需将用例执行状态改为【错误】，并填写和提交缺陷报告。
- 报告缺陷的方式有两种：
  - 方法 1：在执行测试用例的过程中，用例执行失败，触发提交缺陷；  
  - 方法 2：在缺陷视图中，直接提交缺陷，适合于非用例执行过程中（例如，随机测试）发现缺陷的情况。
- 最终由项目经理登录系统，查看项目进度、缺陷统计、项目分析等。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 功能测试与性能测试

## 1 功能测试与工具

### 功能测试概述
- 功能测试
  - 主要针对系统的功能需求展开测试，以确认被测系统是否满足用户的功能使用要求。
  - 功能测试是系统测试中最基本的测试。
- 设计测试用例
  - 功能测试主要结合黑盒测试的基本思想，从三个方面设计测试用例
  - 系统输入 
    - 合法/非法
  - 系统内部处理
    - 数据计算/数据存储
  - 系统输出
    - 正常输出/提示输出/输出设备输出
- 功能测试的执行
  - 手工方式
  - 自动化方式

### 自动化测试概述
- 自动化测试
  - 自动化测试含义
    - 通过测试工具、测试脚本等手段，按照测试工程师的预定计划对软件产品进行自动的测试，从而验证软件是否满足用户的需求。
  - 自动化测试特点：
    - 良好的可重复性、可操作性和高效率等。
  - 功能自动化测试的基本任务
    - 模拟手工执行测试的过程
    - 即模拟用户对被测系统的手工操作，记录执行过程，判断测试用例执行结果，统计测试相关情况。
    - ![自动化测试-登录功能示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%A4%BA%E4%BE%8B.png)
- 功能自动化测试工具涉及的相关技术：
  - 录制/回放技术和脚本技术。
- 录制/回放技术
  - 测试过程：
    - 自动录制手工操作，转化为测试脚本；
    - 通过在脚本中插入指令来设置校验点； 
    - 测试工具通过读取脚本，执行插入的指令，并根据脚本的设置重复执行指定的测试用例
  - 优势
    - 快速得到可回放的测试比较结果
    - 自动生成可直接使用的测试脚本
    - 自动准备测试数据
    - 回归测试中可准确重复执行指定测试用例 
- 脚本技术
  - 概述
    - 具有与一般编程语言非常类似的语法结构
    - 多为解释型语言，可以方便地在IDE中对脚本进行编辑和修改。
  - 脚本技术提供的常见功能
    - 支持多种常用变量和数据类型。
    - 支持数组、列表、结构和其他混合数据类型。
    - 支持各种条件逻辑和循环结构。
    - 支持函数的创建和调用。
    - 支持文件读写和数据源连接。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 2 AR

### AR概述
- 概述
  - AutoRunner（简称 AR）是一款自动化测试工具软件
  - 适用于功能测试、回归测试、组合测试和大数据量测试。
  - ![AR的作用图示](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9B%BE%E7%A4%BA.png)
- 基于 AR 的自动化功能测试流程
  - 按照测试计划，设计测试用例；
  - 根据测试用例的要求录制测试脚本；
  - 添加校验点和必要的测试数据；
  - 运行脚本；
  - 观察测试日志，如果有缺陷，则提交缺陷报告；
  - 重复运行脚本，判断运行结果与预期结果是否一致。
  - ![AR的测试流程图示](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E5%9B%BE%E7%A4%BA.png)
- AR的测试脚本组成
  - 测试脚本：定义测试活动执行的顺序和逻辑；
  - 对象库：定义测试活动中操作的对象、属性、样式等；
  - 参数化和数据池：这是对单一测试脚本执行单一流程和数据的扩展。
  - ![AR测试脚本的构成](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%9A%84%E6%9E%84%E6%88%90.png)
  - ![AR界面构成](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR%E7%95%8C%E9%9D%A2%E6%9E%84%E6%88%90.png)

### AR的使用
- AR的基本操作
  - 新建项目
  - 新建脚本
  - 录制脚本，并保存
  - 回放脚本
- 图示
  - 新建项目
    - ![AR-新建项目1-法1](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE1.png)
    - ![AR-新建项目2-法2](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE2.png)
    - ![AR-新建项目3-窗口](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE3.png)
  - 新建脚本
    - ![AR-新建脚本1-方法](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E6%96%B0%E5%BB%BA%E8%84%9A%E6%9C%AC1.png)
    - ![AR-新建脚本2-窗口](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E6%96%B0%E5%BB%BA%E8%84%9A%E6%9C%AC2.png)
  - 录制脚本，并保存
    - ![AR-录制脚本按钮介绍](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC%E6%8C%89%E9%92%AE%E4%BB%8B%E7%BB%8D.png)
    - ![AR-录制脚本窗口](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC%E7%AA%97%E5%8F%A3.png)
    - ![AR-录制脚本操作](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9C.png)
  - 回放脚本
    - ![AR-执行脚本操作](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9C.png)
    - ![AR-执行脚本结果](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%BB%93%E6%9E%9C.png)
- 录制对话框
  - 勾选全新录制：脚本编辑区的代码会自动清空，只保留本次录制的内容
  - 未勾选全新录制：脚本编辑区的代码会保留原有的，然后新增录制的内容
- 自动生成的脚本内容
  - 脚本录制完，会在工作空间内自动生成四个文件
  - `*.bsh`为脚本文件，保存了脚本编辑器中的脚本
  - `*.xls`为参数表文件，是一个excel表格，所有的参数化数据都将被保存到这里，当然在我们没用到参数化时，此文件中无数据
  - `*.xml`为对象库文件，是一个xml格式，前面我们看到的对象库信息会被保存到这里，对象库可以进行编辑，编辑后也会被保存下来
  - `*.logd`是日志文件
- AR其他操作
  - 脚本参数化
    - 一条普通脚本只能执行某个特定的动作，将脚本参数化后则可以执行不同的功能。
    - 降低脚本的重复书写，提高脚本的利用率
    - 脚本参数化之前，必需要编辑好参数表。
    - 步骤：
      - 1-录制脚本；
      - 2-编辑参数表；
      - 3-编辑脚本：加入(编辑-循环参数表)；
      - 4-把需要的部分加入for循环里；
      - 5-更改脚本里面的循环语句，以关联到参数表中的数据；
      - 6-修改完毕，可以执行脚本了。
  - 手工添加对象
    - 在以下情况下可能需要手工添加对象到对象库中：
      - 回放时出现某个对象在对象库中没有找到的错误；
      - 由于错误修改对象属性导致回放失败；
      - 某些对象在录制时不方便录制或是录制失败；
      - 不想重录已有脚本，只是想增加某个或某几个新对象到对象库
    - 增加对象步骤
      - 打开对象库，点击“增加对象”，就可以捕获对象了，
      - 捕获对象的时候要按住ctrl+alt键
  - 添加校验点
- AR脚本循环体
  - 法1：点击菜单【编辑】→【循环参数表】
  - 法2：直接点击工具栏的循环参数表按钮
  - 法3：在脚本编辑器中右击
- 图示
  - 脚本参数化
    - ![AR-脚本参数化-编辑参数表](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0%E5%8C%96-%E7%BC%96%E8%BE%91%E5%8F%82%E6%95%B0%E8%A1%A8.png)
    - ![AR-脚本参数化-脚本循环体](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0%E5%8C%96-%E8%84%9A%E6%9C%AC%E5%BE%AA%E7%8E%AF%E4%BD%93.png)
    - ![AR-脚本参数化-加入for循环](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0%E5%8C%96-%E5%8A%A0%E5%85%A5for%E5%BE%AA%E7%8E%AF.png)
    - ![AR-脚本参数化-修改代码关联参数表](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0%E5%8C%96-%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E5%85%B3%E8%81%94%E5%8F%82%E6%95%B0%E8%A1%A8.png)
    - ![AR-脚本参数化-再次执行脚本](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0%E5%8C%96-%E5%86%8D%E6%AC%A1%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC.png)
  - 手工添加对象
    - ![AR-手动添加对象](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%AF%B9%E8%B1%A1.png)
    - ![AR-手动删除对象](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-AR-%E6%89%8B%E5%8A%A8%E5%88%A0%E9%99%A4%E5%AF%B9%E8%B1%A1.png)
   - 添加校验点

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 3 性能测试与工具

### 性能测试
- 性能测试是指
  - 通过模拟软件实际生产运行过程中的业务压力，或用户使用场景，来测试软件系统的性能是否满足实际生产性能的要求。
- 通俗地讲：
  - 性能测试的目的是要检验被测软件系统能否更快、更好地完成执行相关功能。

### 功能测试与性能测试的区别
- 性能测试对测试环境的干净、独立性要求更高，更为严格。
- 一个相对较规范的公司，都会建立其独立的研发环境、测试环境、线网环境（最终运行软件的环境）

### 性能测试环境
- 性能测试环境包括
  - 硬件环境、软件环境及网络环境
  - 硬件：服务器、客户端、交换机等。
  - 软件：数据库、中间件、被测系统、操作系统等。
  - 网络：有线/无线/宽带、网络协议等
- 一般web应用系统分为3层架构
  - 表现层（web服务器）
  - 业务逻辑层（应用服务器）
  - 数据层（数据库服务器）
- 保证测试环境与真实环境的一致性
  - 硬件环境，包括服务器环境、与网络环境
  - 软件环境，包括版本一致性，场景一致性 
- 根据客户需求调整性能测试环境实施的策略：
  - 通过建模的方式实现低端硬件对高端硬件的模拟
    - 通过配置测试来计算不同配置下的硬件性能和系统处理能力的关系，从而推导出满足系统性能的真实配置情况
    - 这种模拟需要精确的建模，模型的采样点越多，那么得到的结果越精确
    - 从而将在低端配置下的性能指标通过该模型转化为高端配置下的最终预计性能指标
  - 通过集群的方式计算
    - 对于较大的系统来说，单台服务器的处理能力是有限的，
    - 通常都会采用集群的方式来进行负载均衡，完成对海量请求的处理。
    - 虽然无法获得整体集群的测试环境，但是可以对集群上的一个节点进行性能测试，得出该节点的处理能力，再计算每增加一个节点的性能损失。

### 性能测试过程
- 性能测试和功能测试一样需要有一个完整的测试过程
  - 1、性能测试计划
  - 2、性能测试需求分析
  - 3、性能测试用例的编写
  - 4、性能测试用例执行
  - 5、性能测试分析
  - 6、性能测试报告

### 性能测试工具概述
- 商业工具
  - QA Load、 SilkPerformer、LoadRunner、WebRunner、IBM Rational Performance Tester、PerformanceRunner等。
  - LoadRunner：
    - 一种较高规模适应性的，自动负载测试工具，它能预测系统行为，优化性能。
    - 强调的是整个企业的系统，它通过模拟实际用户的操作行为和实行实时性能监测，来帮助您更快的确认和查找问题。
    - 支持最宽范的协议和技术，为您的特殊环境，量身定做地提供解决方案。
  - PerformanceRunner
    - 简称PR
    - 是国内首个商业化性能测试工具，通过模拟海量用户并发测试整个系统的承受能力，实现压力测试、性能测试、配置测试、峰值测试等。
    - 支持http，tcpip，udp，sip等不同类型网络协议的性能测试
    - 可实现长连接和短连接等不同模式的测试
    - 企业使用PR能最大限度地缩短测试时间，优化性能和加速应用系统的发布周期
- 开源工具
  - Apache JMeter（一般我们称jmeter）、AutoBench 、curl-loader、Iago等

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->

## 4 PR

### PR概述
- 简介
  - PerformanceRunner（简称 PR）是一款性能测试工具软件。

- ### PR的测试流程如下：
  - 制定测试计划；
  - 生成测试脚本；
  - 创建场景；
  - 运行场景；
  - 监控测试场景；
  - 分析测试结果。
- PR界面介绍
  - 底部大标签：生成器、执行器、分析器
  - 生成器：
    - 脚本录制和编辑：包括脚本参数化、插入事务、插入集合点、参数表设置等。
  - 执行器：
    - 左上角两个标签：设计(设计场景)、运行(运行设计的场景)。
    - 设置场景：包括新建场景项目、启动组设置、启动虚拟用户、持续时间设置、停止虚拟用户、运行等。
  - 分析器：
    - 对执行结果进行分析：虚拟用户图、事务概要图、事务相应时间、每秒事务数、事务性能概要、每秒点击量、吞吐量(字节、兆)等。
- 录制脚本
  - 要创建一个自动测试，首先要创建自动测试脚本，成千上万的虚拟用户正是通过执行测试脚本来对系统施压的；
  - 录制脚本可以监视并记录客户端和服务器端之间的通话，让虚拟用户模拟实际的业务流程，记录真正用户的操作行为，并将其转化为特定的测试脚本语言集合
  - 录制脚本后，会出现三个脚本文件：
    - Action.bsh：存放实际的操作脚本，可多次执行，可创建多个Action脚本
    - Init.bsh:一般用于存放应用程序初始化脚本
    - Uninit.bsh：一般用于存放应用程序注销或关闭脚本
- 参数化
  - 如果想让多个虚拟用户使用几个不同的实际发生数据来执行同一脚本，就需要对脚本进行参数化；
  - 参数化后的脚本在运行的时候是使用多套不同的数据项服务器发起请求或执行某个操作，这样就更接近真实的情况
  - PR通过参数化来实现虚拟用户行为的差异化。
- 参数化代码
  - `pr.parameterData.getFrom("xx")`
  - `pr.getParamValue("username")`
  - 注：用两个加号来连接参数化代码和原代码
- 事务概述
  - 事务：就是在脚本中定义的某段操作，也可以说是一段脚本语句。
  - 录制的脚本没有插入事务时，是一个整体，很难分析系统瓶颈是哪些动作导致的；
  - 引入事务：
    - 可以把一个较大的脚本中不同的动作，分成不同的事务，然后进入性能分析；
    - 这样在性能分析里边就会把每个事务分别进行分析，并且可以更详细，具体地知道是用户的哪些动作对系统性能影响比较大
  - PR通过定义事务来支持更好地分析并发用户的操作响应时间；
- 定义事务
  - 定义事务时，首先在脚本中找到事务的开始和结束位置，然后分别插入起始标记
  - 脚本运行的时候，PR会自动在事务的起始点开始计时，脚本运行到事务的结束点时计时结束，系统会自动记录这段操作的运行时间等性能数据
  - 在脚本运行完毕以后，系统会在结果信息中单独反应每个事务的运行结果
- 插入事务代码
  - `pr.startTransaction(“t1”);//开始`
  - `....code....`
  - `pr.endTransaction(“t1”);//结束`
- 插入集合点
  - 系统负荷最大的情况是所有用户都集中到系统瓶颈的某个点上进行操作。
  - PR提供了集合点的功能，帮助测试人员实现真正意义上的并发。
- 插入集合点代码
  - `pr.rendezvous("search");`
- 设置场景
  - 场景用来模拟真实世界的用户如何产生压力。
  - PR 通过测试场景来对虚拟用户脚本、以及运行虚拟用户的执行器进行配置，从而模拟真实情况下服务器承受的压力。
- 场景设置步骤
  - 文件-新建(场景)--命名--打开场景脚本、场景计划、虚拟用户图；
  - 场景脚本窗口中：添加项目--选择项目(上一部分编辑的脚本)--勾选导入的项目；
  - 打开脚本监控文件`runAgent.bat`；
  - 场景计划窗口中：对新建场景项目、启动组设置、启动虚拟用户、持续时间设置、停止虚拟用户进行参数设置。
  - 场景计划设置后，可以看到右下方虚拟用户图相应变化；
  - 切换左上标签为"运行"，然后点击运行：可以看到运行过程中的动态监测图，并等待运行结束；
  - 切换到右下的"分析器"标签，点击生成，并选择参数，确定后即可查看生成的分析图。
- 测试结果分析
  - 场景执行结束后，需要对测试结果进行分析。
  - PR 通过提供虚拟用户图、事务概要图、事务响应时间、每秒通过事务数、事务性能概要图、每秒点击量、吞吐量等维度，帮助测试人员分析系统相关性能。

### PR使用
- PR界面及菜单介绍
  - ![PR界面](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D.png)
  - ![PR菜单](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E8%8F%9C%E5%8D%95%E4%BB%8B%E7%BB%8D.png)
- 新建项目
  - 新建或在项目区域右击
  - 新建后生成三个脚本文件
- 脚本录制
  - 选中action脚本后点击开始录制
  - ![PR脚本录制](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC.png)
  - ![PR脚本参数](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0.png)
- 事务
  - ![PR添加事务起始和终止](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E6%A0%87%E8%AE%B0%E4%BA%8B%E5%8A%A1.png)
- 集合点
  - ![PR添加集合点](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E6%8F%92%E5%85%A5%E9%9B%86%E5%90%88%E7%82%B9.png)
- 参数化
  - ![PR-脚本参数化操作截图-后](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0%E5%8C%96%E6%93%8D%E4%BD%9C%E6%88%AA%E5%9B%BE-%E5%90%8E.png)
  - ![PR-脚本参数表设置-后](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0%E8%A1%A8%E8%AE%BE%E7%BD%AE-%E5%90%8E.png)
- 关联
  - ![PR-脚本关联](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E8%84%9A%E6%9C%AC%E5%85%B3%E8%81%94.png)
- 场景创建及添加项目
  - 切换到"执行器"标签
  - ![PR-创建场景并添加项目](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E5%88%9B%E5%BB%BA%E5%9C%BA%E6%99%AF%E5%B9%B6%E6%B7%BB%E5%8A%A0%E9%A1%B9%E7%9B%AE.png)
- 场景细节设置
  - ![PR-场景细节设置](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E5%9C%BA%E6%99%AF%E7%BB%86%E8%8A%82%E8%AE%BE%E7%BD%AE.png)
- 场景执行
  - ![PR-场景执行](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E5%9C%BA%E6%99%AF%E6%89%A7%E8%A1%8C.png)
- 分析器介绍
  - ![PR-分析器分析结果生成](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E5%88%86%E6%9E%90%E5%99%A8%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90.png)
  - ![PR-浏览器打开生成的报告图](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/06-PR-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E7%94%9F%E6%88%90%E7%9A%84%E6%8A%A5%E5%91%8A%E5%9B%BE.png)

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->





# 单元测试

## 1 单元测试

### 单元测试概述
- 定义
  - 单元测试是指对软件中的最小可测试单元或基本组成单元进行检查和验证。
  - 一般地，一个单元应具有明确的功能定义、性能定义，以及连接其他部分的接口定义等，且应可以清晰地与其他单元区分开来。
- 测试对象
  - 一个函数、一个类、一个窗口都可以看做是一个单元
  - 在此所指的单元主要是指函数。

### 单元测试的目的和方法
- 测试目的
  - 以分析单元的逻辑结构为基础，针对逻辑结构 结合功能 设计测试用例。
- 测试方法
  - 一般以白盒测试为主、结合黑盒测试的方法。允许多个测试单元的测试并行展开。
  
### 单元测试的内容
- 概述
  - 单元测试的主要内容包括静态测试和动态测试
    - 静态测试即查看程序源代码，执行代码扫描；
    - 动态测试则需要运行程序，完成测试，主要包括对 模块接口、模块边界条件、模块独立路径和错误处理 进行测试。
- 细节
  - 功能测试
  - 语句和分支覆盖率
  - 模块设计是否合理
  - 输入和输出接口测试
  - 内部数据流测试
  - 其它要特定要求的测试
- 策略
  - 逻辑覆盖
  - 循环覆盖
  - 同行评审
  - 桌前检查
  - 代码走查
  - 代码评审
  - 静态数据流分析 
- 单元测试的主要技术手段
  - mock：
    - 对代码中某些不容易获取的对象创建虚拟对象来测试 
  - stub：
    - 桩函数是代替某些被调用了但是没有编写代码，一般再增量迭代自底向上的过程中不用编写。再自顶向下的过程中需要编写 
  - 驱动函数：
    - 调用被测函数，给被测函数传参  
  - 注：
    - GUI测试是系统测试手段。 
  
### 单元测试的实施步骤
- 步骤概述
  - 理解需求和设计； 
  - 概览源代码；(粗略地)
  - 走读代码；(认真地)
  - 设计测试用例； 
  - 搭建测试环境；
  - 执行测试用例，
    - 注意：此时可能需要设计开发驱动模块或桩模块； 
  - 重复进行设计测试用例和加载测试；
  - 分析判断，给出结论。
- 理解需求和设计
  - ![理解需求和设计](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-%E7%90%86%E8%A7%A3%E9%9C%80%E6%B1%82%E5%92%8C%E8%AE%BE%E8%AE%A1.png)
- 搭建测试环境
  - ![搭建测试环境](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83.png)
  - 驱动模块和桩模块：
    - 当某个模块开发完成，而其他模块还没时，为了完整地运行已开发完成模块而进行的补充。
  - 驱动模块：
    - 模拟包含主函数的模块的功能。
  - 桩模块：
    - 模拟除了某模块和包含主函数的模块之外，使得程序顺利运行编译的后续模块。

### 单元测试自动化
- 按照预定的规范自动扫描对象，大大降低单元测试第一步人工检查的复杂性，提高代码的规范性

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 2 代码扫描工具CA

### CA概述
- 概述
  - 代码扫描工具 Code Analyzer（简称 CA）
  - 通过分析或检查源程序的语法、结构、过程以及接口来检查程序的正确性和规范性，找出代码中隐藏的错误和缺陷，提高代码质量。
  - CA 检查源代码的过程不需要实际执行程序，是一种自动静态检查的软件工具。
- CA的界面
  - ![CA的界面](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA%E7%95%8C%E9%9D%A2.png)
- CA的架构 
  - ![CA的架构](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA%E6%9E%B6%E6%9E%84.png)
- CA的特点
  - 多系统、多语言、跨平台支持
  - 无需测试用例的测试
  - 基于编译的代码分析
  - 集成与扩展性
  - 代码级测试覆盖
  - 多样化分析报告

### CA的功能
- 支持规则列表
  - 词法规则：CA支持英语的单词表，变量命名的定义来自于词表检查
  - 语法规则：CA通过标准化的语法模板来处理语义规则
  - 语义规则：CA通过调用标准化的处理程序来分析定义的规则
    - 支持用户开发自己的规则包，然后通过配置文件以插件的形式配置到CA中。 
- 发现不符合编码规范的代码
  - 在扫描源代码时对安全规范子集中定义的规则进行逐条检查；
  - 如果发现有不符合项则报告在问题列表中，用户可通过行号、列号精确定位问题。
- 自动监控版本服务器，触发代码扫描及检测分析
  - CA可以通过以下方式来实现修改配置管理的提交脚本，潜入扫描触发程序。
  - 当用户check in程序的时候，脚本触发了CA，来进行代码扫描，并且提交扫描结果
- 支持云服务实现，支持跨internet实现源代码安全扫描“云服务”
  - CA可支持私有云服务的版本：通过本地化来扫描程序，生成xml，上传到云服务，再进行扫描处理，在云端保存扫描结果，并且提供浏览器访问服务。
- 支持主流IDE环境，开发人员桌面上即可进行扫描
  - CA支持通过命令行方式嵌入IDE的方式，可以通过配置IDE环境来调用命令行工作；
  - 也支持通过提供客户端的方式来工作，用户可以通过操作客户端来扫描制定的代码，甚至整个项目。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


## 3 CA的使用

### CA的代码分析流程
- 具体流程
  - 代码预处理；
  - 对代码进行语法分析；
  - 生成代码执行树；
  - 对代码进行语义分析；
  - 生成分析报告。
- 图示
  - ![CA代码分析流程图示](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%A4%BA.png)


### CA的使用
- 使用概述
  - 非常简单，只需要导入源代码，设置好规则包，就可以启动执行代码分析；
  - 执行完毕后，产生执行日志，对源代码的分析结果将显示在错误日志中，提供查看。
- 使用图示
  - ![CA-导入源代码](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA-%E5%AF%BC%E5%85%A5%E6%BA%90%E4%BB%A3%E7%A0%81.png)
  - ![CA-执行代码分析](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA-%20%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.png)
  - ![CA-生成代码日志](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA-%E4%BA%A7%E7%94%9F%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97.png)

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->




## 参考链接
- 相关仓库：
  - [GitHub: anliux/SoftwareTest](https://github.com/anliux/SoftwareTest)
- 相关博文：
  - [博客园：面筋-测试常见问题合集](https://www.cnblogs.com/anliux/p/12565200.html)

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->


### END
